<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>你就只是一个过客</title>
        <description>你就只是一个过客 - kason</description>
        <link></link>
        <link></link>
        <lastBuildDate>2014-04-14T22:35:42+08:00</lastBuildDate>
        <pubDate>2014-04-14T22:35:42+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>linux_wget 下载</title>
                <description>&lt;p&gt;4 建立简单的robots.txt文件：&lt;/p&gt;

&lt;p&gt;$ cat robots.txt User-agent: * Disallow: rocrocket-2.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这个文件的内容就是要屏蔽rocrocket-2文件的下载和spider。

5 我们用wget来下载这个测试站点：&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wget -r http://my-test.cn:61212/&lt;/p&gt;

&lt;p&gt;$ ls -1 index.html robots.txt rocrocket-1-1.html rocrocket-1-2.html rocrocket-1.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;看！下载到的包含了robots.txt文件，但没有包含rocrocket-2及其相关的文件。

可见，robots.txt生效了，wget遵守了robots.txt的规则！

6 我如何突破robots.txt的限制呢？

使用-execute选项就可以，这个选项的作用是将其后的参数模拟“放到.wgetrc中的执行效果”。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$ wget -r &amp;#8211;execute robots=off http://jx-nsop-test0.jx:61212/&lt;/p&gt;

&lt;p&gt;$ ls -1 index.html rocrocket-1-1.html rocrocket-1-2.html rocrocket-1.html rocrocket-2-1.html rocrocket-2-2.html rocrocket-2.html&lt;/p&gt;</description>
                <link>/linux/2013/11/04/linux_wget</link>
                <guid>/linux/2013/11/04/linux_wget</guid>
                <pubDate>2013-11-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>linux_PS1</title>
                <description>&lt;h2 id='linuxps1'&gt;linux下面的$PS1的设置&lt;/h2&gt;

&lt;p&gt;下面简单说说环境下默认的特殊符号所代表的意义： \d ：代表日期，格式为weekday month date，例如：&amp;#8221;Mon Aug 1&amp;#8221; \H ：完整的主机名称。例如：我的机器名称为：fc4.linux，则这个名称就是fc4.linux \h ：仅取主机的第一个名字，如上例，则为fc4，.linux则被省略 \t ：显示时间为24小时格式，如：HH：MM：SS \T ：显示时间为12小时格式 \A ：显示时间为24小时格式：HH：MM \u ：当前用户的账号名称 \v ：BASH的版本信息 \w ：完整的工作目录名称。家目录会以 ~代替 \W ：利用basename取得工作目录名称，所以只会列出最后一个目录 # ：下达的第几个命令 \$ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$&lt;/p&gt;

&lt;p&gt;[\e&lt;span&gt;F;Bm] 其中&lt;code&gt;F&amp;#39;&amp;#39;为字体颜色，编号30~37；&lt;/code&gt;B&amp;#8221;为背景色，编号40~47。 可通过&lt;code&gt;\e[0m&amp;#39;&amp;#39;关闭颜色输出；特别的，当B为1时，将显示加亮加粗的文字，详细请看下面的颜色表与代码表。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;颜色表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;前景 | 背景 | 颜色
-----|------|-----
30   | 40   | 黑色
31   | 41   | 紅色
32   | 42   | 綠色
33   | 43   | 黃色
34   | 44   | 藍色
35   | 45   | 紫紅色
36   | 46   | 青藍色
37   | 47   | 白色&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='_'&gt;代码 意义&lt;/h2&gt;

&lt;p&gt;0 OFF 1 高亮显示 4 underline 5 闪烁 7 反白显示 8 不可见&lt;/p&gt;</description>
                <link>/linux/2013/11/04/linux_ps1</link>
                <guid>/linux/2013/11/04/linux_ps1</guid>
                <pubDate>2013-11-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>php数组索引</title>
                <description>&lt;h2 id='php'&gt;php的数组索引的问题&lt;/h2&gt;

&lt;p&gt;数组的索引可以用单引号，双引号，或者不用（只要把notice关闭就可以了）&lt;/p&gt;

&lt;p&gt;其实：&lt;/p&gt;

&lt;p&gt;- 对于整形的索引值，不必加单双引号（因为加了就会把整形当成了字符串，解释时要把客串转为整形来解释） －以字符串作为索引的如果不加单双引号就有可能会出现问题，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
define(&amp;#39;name&amp;#39;,&amp;#39;abddddd&amp;#39;);
$arr = array(&amp;#39;name&amp;#39;=&amp;gt;&amp;#39;wangwu&amp;#39;,&amp;#39;ccc&amp;#39;=&amp;gt;&amp;#39;bbbb&amp;#39;);
echo $arr[name];
?&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;规律：如果定义了索引的字符串为常量，则数组的索引会被解释为常量所定义的值来解释。&lt;/p&gt;</description>
                <link>/php/2013/10/31/php_index</link>
                <guid>/php/2013/10/31/php_index</guid>
                <pubDate>2013-10-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>vim tabular插件</title>
                <description>&lt;h2 id='vim_tabular'&gt;vim tabular插件&lt;/h2&gt;

&lt;p&gt;vim tabular插件是一个让一些文本的特定的对齐插件，如下面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$goods_id =$_POST[&amp;#39;goods_id&amp;#39;];
$goods_name = $_POST[&amp;#39;goods_name&amp;#39;];
$goods_class = $_POST[&amp;#39;goods_class&amp;#39;];
$goods_number = $_POST[&amp;#39;goods_number&amp;#39;]

$goods_id     = $_POST[&amp;#39;goods_id&amp;#39;];
$goods_name   = $_POST[&amp;#39;goods_name&amp;#39;];
$goods_class  = $_POST[&amp;#39;goods_class&amp;#39;];
$goods_number = $_POST[&amp;#39;goods_number&amp;#39;]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码如果想格式化为下面那种的对齐方式，你只需要把光标移到要对齐的行上面，然后进入命令行的模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:Tab /= &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以实现了,注意到那命令的格式，要按照＝对齐就是 :Tab/=,那我大胆的假设一下，只要输入这个命令就会按照后面的那个字符对齐的。于是我做了下在的测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;abcccccc   d fggggggg
a          d ffffggggh
bfwerefgkj d s         d kfjjk&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我输入了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:Tab /d&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;果然它就按照d来对齐了，而且d的两边都有一个空格!!&lt;/p&gt;</description>
                <link>/vim/2013/10/29/vim_tabular</link>
                <guid>/vim/2013/10/29/vim_tabular</guid>
                <pubDate>2013-10-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>linux下面的快捷键</title>
                <description>&lt;h1 id='linux'&gt;linux的快捷键&lt;/h1&gt;

&lt;p&gt;在命令行下的的快捷键：&lt;/p&gt;

&lt;h2 id='id2'&gt;删除&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ctrl + d      //删除光标所在位置上的字符相当于VIM里x或者dl
ctrl + h      //删除光标所在位置前的字符相当于VIM里hx或者dh
ctrl + k      //删除光标后面所有字符相当于VIM里d shift+$
ctrl + u      //删除光标前面所有字符相当于VIM里d shift+^
ctrl + w      //删除光标前一个单词相当于VIM里db
ctrl + y      //恢复ctrl+u上次执行时删除的字符
ctrl + ?      //撤消前一次输入
alt  + r      //撤消前一次动作
alt  + d      //删除光标所在位置的后单词&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id3'&gt;移动&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ctrl + a			   //将光标移动到命令行开头相当于VIM里shift+^
ctrl + e			   //将光标移动到命令行结尾处相当于VIM里shift+$
ctrl + f			   //光标向后移动一个字符相当于VIM里l
ctrl + b			   //光标向前移动一个字符相当于VIM里h
ctrl + 方向键左键     //光标移动到前一个单词开头
ctrl + 方向键右键     //光标移动到后一个单词结尾
ctrl + x       	   //在上次光标所在字符和当前光标所在字符之间跳转
alt  + f      		   //跳到光标所在位置单词尾部&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id4'&gt;替换&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ctrl + t       //将光标当前字符与前面一个字符替换
alt  + t       //交换两个光标当前所处位置单词和光标前一个单词
alt  + u       //把光标当前位置单词变为大写
alt  + l       //把光标当前位置单词变为小写
alt  + c       //把光标当前位置单词头一个字母变为大写&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id5'&gt;历史命令编辑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ctrl + p       //返回上一次输入命令字符
ctrl + r       //输入单词搜索历史命令
alt  + p       //输入字符查找与字符相接近的历史命令&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id6'&gt;其它&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ctrl + s      //锁住终端
ctrl + q      //解锁终端
ctrl + l      //清屏相当于命令clear
ctrl + c      //另起一行
ctrl + i      //类似TAB健补全功能
ctrl + o      //重复执行命令
alt  + 数字键 //操作的次数&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='vim'&gt;VIM下的快捷键：&lt;/h1&gt;

&lt;h3 id='id7'&gt;复制、删除：&lt;/h3&gt;

&lt;p&gt;yw 表示拷贝从当前光标到光标所在单词结尾的内容.&lt;/p&gt;

&lt;p&gt;　　dw 表示删除从当前光标到光标所在单词结尾的内容.&lt;/p&gt;

&lt;p&gt;　　y0 表示拷贝从当前光标到光标所在行首的内容.&lt;/p&gt;

&lt;p&gt;　　d0 表示删除从当前光标到光标所在行首的内容.&lt;/p&gt;

&lt;p&gt;　　y$ 表示拷贝从当前光标到光标所在行尾的内容.&lt;/p&gt;

&lt;p&gt;d$ 表示删除从当前光标到光标所在行尾的内容.&lt;/p&gt;

&lt;p&gt;移动：&lt;/p&gt;

&lt;p&gt;w(e) 移动光标到下一个单词.&lt;/p&gt;

&lt;p&gt;　　b 移动光标到上一个单词.&lt;/p&gt;

&lt;p&gt;　　0 移动光标到本行最开头.&lt;/p&gt;

&lt;p&gt;　　^ 移动光标到本行最开头的字符处.&lt;/p&gt;

&lt;p&gt;　　$ 移动光标到本行结尾处.&lt;/p&gt;

&lt;p&gt;　　H 移动光标到屏幕的首行.&lt;/p&gt;

&lt;p&gt;　　M 移动光标到屏幕的中间一行.&lt;/p&gt;

&lt;p&gt;　　L 移动光标到屏幕的尾行.&lt;/p&gt;

&lt;p&gt;　　gg 移动光标到文档首行.&lt;/p&gt;

&lt;p&gt;　　G 移动光标到文档尾行.&lt;/p&gt;

&lt;h2 id='id8'&gt;常用：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;H ：光标移至屏幕顶行
M ：光标移至屏幕中间行
L ：光标移至屏幕最后行
0：（注意是数字零）光标移至当前行首
$：光标移至当前行尾

w或W ：光标右移一个字至字首
b或B ：光标左移一个字至字首
e或E ：光标右移一个字至字尾
Ctrl+u：向文件首翻半屏
Ctrl+d：向文件尾翻半屏
Ctrl+f：向文件尾翻一屏
Ctrl＋b；向文件首翻一屏

i ：在光标前
I ：在当前行首
a：光标后
A：在当前行尾
o：在当前行之下新开一行
O：在当前行之上新开一行
r：替换当前字符
R：替换当前字符及其后的字符，直至按ESC键&lt;/code&gt;&lt;/pre&gt;</description>
                <link>/linux/2013/10/28/linux_shortcuts</link>
                <guid>/linux/2013/10/28/linux_shortcuts</guid>
                <pubDate>2013-10-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Linux 的samba配置</title>
                <description>&lt;p&gt;comment 描述 browseable = no 无权限共享目录隐藏起来， writable = yes 对目录是否可写&lt;/p&gt;

&lt;p&gt;linux下面的防火墙 1、Netfilter/Iptables iptables -F //关闭防火墙 2、SELinux #/etc/selinux/config SELINUX=disables&lt;/p&gt;</description>
                <link>/linux/2013/10/27/samba</link>
                <guid>/linux/2013/10/27/samba</guid>
                <pubDate>2013-10-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ubuntu的使用技巧</title>
                <description>&lt;h1 id='ubuntu'&gt;ubuntu&lt;/h1&gt;

&lt;h1 id='id1'&gt;#&lt;/h1&gt;

&lt;h2 id='ubuntuibus'&gt;ubuntu的ibus的输入状态栏的显示&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;gconftool &amp;#8211;type boolean -s /desktop/ibus/panel/show_icon_on_systray true&lt;br /&gt;gconftool &amp;#8211;type boolean -s /desktop/ibus/panel/show true&lt;br /&gt;gsettings set com.canonical.Unity.Panel systray-whitelist &amp;#8221;&lt;span&gt;&amp;#8216;all&amp;#8217;&lt;/span&gt;&amp;#8221;&lt;/p&gt;
&lt;/blockquote&gt;</description>
                <link>/linux/2013/10/22/ubuntu</link>
                <guid>/linux/2013/10/22/ubuntu</guid>
                <pubDate>2013-10-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>vim的复制与粘贴</title>
                <description>&lt;h2 id='vim'&gt;vim的复制与粘贴问题。&lt;/h2&gt;

&lt;p&gt;vim是文本编辑器，既然是文本编辑器，那么就会要用到复制与粘贴的功能。&lt;/p&gt;

&lt;p&gt;vim中一般复制是用yy，粘贴用的是p或者大P，其中yy表示复制当前光标的所在行， 如果想复制多行，则可以在yy的前面加上数字：如我想复制当前光标以下的10行， 则只要按10yy就可以把内容复制到粘贴板了。而粘贴小p与大P的区别是粘贴在当前行下 与当前行上的区别。&lt;/p&gt;

&lt;p&gt;vim的复制还有别一种办法，那就是选中(v 进入可视行，ctrl+v进入可视块,hjkl移动选择) 复制的字或者是行，选中后再按y.&lt;/p&gt;

&lt;p&gt;vim中的剪切命令就是dd 要多行的操作跟yy复制相同，（如剪切当前光标以下10行，10dd）&lt;/p&gt;

&lt;p&gt;vim一般的复制粘贴就是这样了，但这些命令并不能把内容复制到系统共享的粘贴板上， 也不能把系统粘贴板上面的内容粘贴到vim当中。&lt;/p&gt;

&lt;p&gt;要是你以为vim没有这个功能，那你就错啦！&lt;/p&gt;

&lt;p&gt;其实vim会把复制到的内容放到十几个寄存器当中，其中有一个就是和系统的粘贴板共享的， 只要我样把内容复制到这个寄存器当中，和把这个寄存器中的内容粘贴到vim上那问题就可以 解决了。&lt;/p&gt;

&lt;p&gt;这个寄存器的名字就是＋，&lt;/p&gt;

&lt;p&gt;那如何把内容复制到寄存器当中呢？&lt;/p&gt;

&lt;p&gt;那就是在复制之前按&amp;#34;加上寄存器的名 再加上 y 就可以了 同样要把寄存器中的内容粘贴到vim当中，只要在粘贴前先按&amp;#8221; 加上寄存器的名 再加上小p或者大P 就可以了。&lt;/p&gt;

&lt;p&gt;那么vim的寄存器有十多个，怎么知道寄存器放的复制内容是什么呢？&lt;/p&gt;

&lt;p&gt;进入命令行模式，reg就可以查看每一个寄存器中的内容了。 其中最后一次复制或者删除的就放在第一个寄存器当中，再次复制或者删除又会把它放在第一个寄存器 当中，原来在这个寄存器中的内容就会放到下一个中，最后就会把第十个寄存器当中的内容丢掉。&lt;/p&gt;</description>
                <link>/vim/2013/10/20/vim_copy_and_parse</link>
                <guid>/vim/2013/10/20/vim_copy_and_parse</guid>
                <pubDate>2013-10-20T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
